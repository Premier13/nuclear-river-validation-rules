# Дизайн агрегатов

Для контекста **"Проверки заказов (прайсы)"** можно выделить три  агрегата:
1. Период (Period)
2. Прайс (Price)
3. Заказ (Order)

# Period

**Причина возникновения агрегата:** проверка заказа интересна не сама по себе, а в контексте конкретного периода размещения.

Рассмотрим ситуацию:
- Заказ O1 на фирму F размещается с 1 по 4 месяц, содержит позицию P1
- Заказ O2 на фирму F размещается с 3 по 4 месяц, содержит позицию P2
- P1 запрещена к P2

Заказ O1 валиден в месяцы с 1 по 3, но невалиден в 4 месяц (есть другой заказ на эту же фирму, но с запрещённой позицией P2).

Проверка заказов должна явно идти в контексте одного или нескольких смежных периодов.
Поэтому необходим агрегат Period, содержащий в себе ссылки на Order и на Price.
Такой агрегат позволит быстро найти все заказы для проверки в конкретном периоде.   

Агрегат Period можно выделить косвенный образом из таблиц фактов Order и Prices.

Логика формирования агрегата: 
- пришёл Order, на основе BeginDistrubutionDate, BeginDistrubutionDatePlan создаём Period.
- если пришёл другой Order с перекрывающимся периодом, то тогда надо подразбить существующий Period
  (будем удалять старый Period и создавать два новых)
- аналогично поступаем с Price, с одним уточнением что у Price нету окончания срока действия, нужен будет особый период у которого EndDate будет не заполнен

Period будет параметризован от проекта, то есть теоритически возможно что у разных проектов будет разная продолжительность периода.   

```   
Period
 |
 |--Order
 |--Price 
```

# Price

**Причина возникновения очевидна:** где-то должны храниться сериализованные правила проверок сопутствия\запрещения и максимальное\минимальное количество рекламы

По сравнению со структурой таблиц фактов предлагается вязять таблицы AssociatedPositions и DeniedPositions напрямую к Price, минуя PricePositions.
Это позволит быстро найти все правила сопутствия\запрещения для конкретного прайса.

В таблицах AssociatedPositions и DeniedPositions хранятся ссылки на номенклатурные позиции
Таблица PricePositions остаётся, она нужна для проверки на колическтво рекламы.   

```
Price
 |
 |--DeniedPositions (Denied, Master)
 |--AssociatedPositions (Associated, Master)
 |
 |--PricePositions (MinAdvAmount, MaxAdvAmount)
```

# Order

**Причина возникновения очевидна:** где-то должны храниться данные для проверки

По сравнению со стурктурой таблиц фактов предлагается:
1. Из OrderPositionAdvertisements явно выделить сущность "Объект привязки"  (LinkedObjects) - для удобновго сравнения проверок на сопутствующие\запрещённые
2. В OrderPositionAdvertisement хранить ссылку на пакетную позицию в дополнение к простым позициям
   > Прямо сейчас в случае оформления пакетной позиции:
   > * Order.OrderPosition.Position - ссылается на пакетную позцию
   > * Order.OrderPosition.OrderPositionAdvertisement.Position - ссылается на простые позиции, составляющие пакет
   
  Чтобы быстро проверить правило, что пакет запрещён к простой позции (а такие правила есть и это нормально), предлагается хранить в OrderPositionAdvertisement и ссылку на пакет и ссылку на простые позиции.

Таким образом из OderPositionAdvertisement будет создана сущность OrderPosition, оптимизированная для проходения проверок.

```
Order
 |
 |--OrderPosition (PackagePositionId, PositionId)
     |
     |--LinkedObject
```

# Взаимодествие агрегатов

Верхнеуровневый алгоритм прохождения проверок по агрегатам (на примере проверки на сопутствующие\запрещённые позиции):
- На входе **период** и **проект**
- По агрегату **Period** определяем набор заказов **OderId** на проверку
- Из агрегата **Order** достаём набор прайсов **PriceId** относительно которых осуществляем проверку
- Из агрегата **Price** достаём набор проверок **AssociatedPositions**, **DeniedPositions**
- Далее из агрегата **Order** перейти к OderPositions, осуществить непосредствено проверку
