![required text](https://immense-sea-86195.herokuapp.com/2gis/nuclear-river/feature/validation-rules/docs/ru/validation-rules/design-aggs.puml)

# Дизайн агрегатов

Для контекста **"Проверки заказов (прайсы)"** можно выделить следующие агрегаты:

1. Период (Period)
2. Прайс (Price)
3. Заказ (Order)
4. Номенклатурная позиция (Position)

# Period

**Причина возникновения агрегата:** необходим простой способ сгруппировать заказы, размещающиеся одновременно, провести параллель между размещенеим заказа и действующим на тот момент прайс-листом.

Рассмотрим ситуацию:
- Заказ O1 на фирму F размещается с 1 по 4 месяц, содержит позицию P1
- Заказ O2 на фирму F размещается с 3 по 4 месяц, содержит позицию P2
- P1 запрещена к P2

Заказ O1 валиден в месяцы с 1 по 3, но невалиден в 4 месяц (есть другой заказ на эту же фирму, но с запрещённой позицией P2).

Проверка заказов должна явно идти в контексте одного или нескольких смежных периодов.
Поэтому необходим агрегат Period, содержащий в себе ссылки на Order и на Price.
Такой агрегат позволит быстро найти все заказы для проверки в конкретном периоде.   

Агрегат Period можно выделить косвенным образом из таблиц фактов Order и Prices.

Логика формирования агрегата: 

- Для пересчёте сущностей Order, Price определяем период действия.
-- для заказа на основании полей BeginDistrubutionDate, EndDistrubutionDatePlan
-- для прайс-листа на основании полей BeginDate текущего и следующего прайс-листов (для последнего используем max(DateTime))
- если данный период может быть представлен в виде суммы существующих сущностей периодов - создаём связи с ними.
- иначе создаём новые или разбиваем существующие периоды - после этого требуется пересчёт ссылок.
- при разбитии периода - старый удаляем.

Period будет параметризован от проекта, то есть теоритически возможно что у разных проектов будет разная продолжительность периода.

В отличе от ERM мы откажемся от правила "последней секунды месяца" и будем хранить/воспринимать периоды как полуинтервалы замкнутые слева и открытые справа.

# Price

**Причина возникновения очевидна:** где-то должны храниться сериализованные правила проверок сопутствия\запрещения и максимальное\минимальное количество рекламы

По сравнению со структурой таблиц фактов предлагается вязять таблицы AssociatedPositions и DeniedPositions напрямую к Price, минуя PricePositions.
Это позволит быстро найти все правила сопутствия\запрещения для конкретного прайса.

В таблицах PriceAssociatedPositions и PriceDeniedPositions хранятся ссылки на номенклатурные позиции
Таблица AdvertisementAmountRestriction служит для хранения ограничений на количество рекламы.

# Order

**Причина возникновения очевидна:** где-то должны храниться проверяемые данные.

По сравнению со стурктурой таблиц фактов предлагается:

1. Из OrderPositionAdvertisements явно выделить сущность "Объект привязки"  (LinkedObject) - для удобновго сравнения проверок на сопутствующие\запрещённые
2. В OrderPosition равнозначно добавлять связи с простыми номенклатурными позициями, пакетными и элементами пакетов. Это делается для того, чтобы иметь возможность быстро проверить правило, что пакет запрещён к простой позции (а такие правила есть и это нормально).
3. Кроме того, для возможности группировки позиций одного пакета требуется сохранять информацию, из которого пакета позиция попала в заказ.

   > Прямо сейчас в случае оформления пакетной позиции:
   > * Order.OrderPosition.Position - ссылается на пакетную позцию
   > * Order.OrderPosition.OrderPositionAdvertisement.Position - ссылается на простые позиции, составляющие пакет
   
Таким образом из OderPosition + OderPositionAdvertisement будет создана сущность OrderPosition, оптимизированная для проходения проверок.