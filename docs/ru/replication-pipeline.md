# Этапы (Stages)
Репликация может происходить в один или несколько этапов. Структура каждого этапа унифицирована и состоит из следующих шагов: _получение_ сообщения из транспорта, _преобразование_, _накопление_ и _обработка_.

### Получение сообщения из транспорта
```csharp
public interface IMessageReceiver
{
    IReadOnlyList<IMessage> Peek();
    void Complete(IEnumerable<IMessage> successfullyProcessedMessages, IEnumerable<IMessage> failedProcessedMessages);
}
```

Метод `Peek` должен получать сообщения из транспорта, но не удалять из него (на случай сбоя обработки).

Метод `Complete` должен удалить из транспорта сообщения `successfullyProcessedMessages` и может обработать сообщения, которые не удалось принять.

Абстрактный класс `MessageReceiverBase` призван упростить реализацию.

### Преобразование
```csharp
public interface IMessageTransformer
{
    bool CanTransform(IMessage originalMessage);
    IMessage Transform(IMessage originalMessage);
}
```

Метод `CanTransform` должен определить, может ли быть сообщение обработано данным экземпляром. Если в наличии несколько - будут опрошены все последовательно (последовательность не определена), до первого, способного обработать.

Метод `Transform` должен выполнить преобразование сообщения из сериализованного представления (принятого из транспорта) в представление, пригодное для использования на следующих этапах.

Если преобразование не требуется, то требуется пустая реализация этого интерфейса. Её отсутствие приведёт к ошибке.

Абстрактный класс `MessageTransformerBase` призван упростить реализацию.

### Накопление
```csharp
public interface IMessageProcessingContextAccumulator
{
    bool CanProcess(IMessage message);
    IAggregatableMessage Process(IMessage message);
}
```

Метод `CanProcess` должен определить, может ли быть сообщение обработано данным экземпляром. Если в наличии несколько - будут опрошены все последовательно (последовательность не определена), до первого, способного обработать.

Метод `Process` может выполнить некоторые дополнительные преобразование сообщения, кроме того, управляя значением Id возвращаемого `IAggregatableMessage`, возможно, разложить сообщения по нескольким корзинам. Если его не менять, то все сообщения попадут в одну корзину.

Абстрактный класс `MessageProcessingContextAccumulatorBase` призван упростить реализацию.

### Обработка
```csharp
public interface IMessageProcessingHandler
{
    IEnumerable<StageResult> Handle(IReadOnlyDictionary<Guid, List<IAggregatableMessage>> processingResultsMap);
}
```
Метод `Handle` должен уже окончательно обработать сообщения и пометить их как успешно обработанные или зафейленные. Сообщения передаются в сгруппированном по Id виде - одна или несколько корзин, сформированных на предыдущем шаге.

Если этот этап должен генерировать команды/события для других этапов, их требуется сформировать и отправить тоже в методе `Handle`.

После его завершения будет вызван `Complete` приёмника для обработанных сообщений.

### Соединение шагов внутри одного этапа
* Требуется реализовать `IMessageFlowReceiverResolveStrategy` и зарегистрировать в DI-контейнере. Реализация должна возвращать тип, реализующий `IMessageReceiver` в ответ на запрос с `messageFlowMetadata`.
* Требуется реализовать `IMessageTransformerResolveStrategy` и зарегистрировать в DI-контейнере. Реализация должна возвращать тип, реализующий `IMessageTransformer` в ответ на запрос с `messageFlowMetadata`.
* Требуется связать идентификатор потока, реализацию `IMessageProcessingContextAccumulator` и реализацию `IMessageProcessingHandler` в метаданных.

> **Замечание:**
> На самом деле, всё определяется `IMessageProcessingStagesFactory`, `IMessageTransformerFactory` и рядом других, которые используются в реализации `IMessageFlowProcessor` и `IMessageProcessingTopology`, которые определяется посредством регистрации `IMessageFlowProcessorResolveStrategy`, которая регистриуется в контейнере... 

### Соединение этапов
На самом деле достаточно условный процесс, поскольку единственный способ соединить два этапа - это переслать сообщения, сгенерированные одним, к другому. А эта задача в настоящий момент лежит вне компетеции платформы **NuClear River**. Вам потребуется некоторая реализация, способная отправлять сообщения в тот поток, который читает слудующий (следующие) этапы.

Но на всякий случай соединение потоков добавляется в тот же самый элемент метаданных, в котором соединены `IMessageProcessingContextAccumulator` и `IMessageProcessingHandler`.
